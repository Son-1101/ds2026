\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}

% Code snippet configuration
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{gray},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    language=Python
}
\lstset{style=mystyle}

\title{Practical Work 4: Word Count (MapReduce)}
\author{Nghiêm Xuân Sơn - ID}
\date{\today}

\begin{document}

\maketitle

\section{Implementation Choice}
For this practical work, I chose to **implement a custom, lightweight MapReduce framework** using Python.

\textbf{Reasoning:}
\begin{itemize}
    \item As per the lab requirement ("Invent yourself"), creating a simulation helps us understand the core mechanics of MapReduce (Splitting, Mapping, Shuffling, Reducing) without the overhead of configuring a complex Hadoop cluster.
    \item Python's dictionary data structure makes the "Shuffle and Sort" phase intuitive and easy to implement.
\end{itemize}

\section{System Design}
My implementation follows the standard MapReduce data flow pipeline:

\begin{figure}[H]
    \centering
    \textbf{Input Text} $\rightarrow$ \textbf{Map Phase} $\rightarrow$ \textbf{Shuffle Phase} $\rightarrow$ \textbf{Reduce Phase} $\rightarrow$ \textbf{Output}
    \caption{Data Flow Pipeline}
\end{figure}

\begin{enumerate}
    \item \textbf{Input:} The system reads the raw text file.
    \item \textbf{Mapper:} It splits the text into words, cleans punctuation, and emits key-value pairs in the format: \texttt{(word, 1)}.
    \item \textbf{Shuffle \& Sort:} It aggregates the emitted pairs by key. It converts a list of pairs into a dictionary where each word maps to a list of occurrences: \texttt{word $\rightarrow$ [1, 1, 1...]}.
    \item \textbf{Reducer:} It takes the list of counts for each word and sums them up to get the final frequency.
\end{enumerate}

\section{Implementation Code}

\subsection{The Mapper}
The Mapper function cleans the word and emits a count of 1.

\begin{lstlisting}[caption=Mapper Implementation]
def mapper(text_chunk):
    results = []
    # Split text and remove punctuation
    words = text_chunk.strip().lower().split()
    for word in words:
        clean_word = word.strip(string.punctuation)
        if clean_word:
            results.append((clean_word, 1))
    return results
\end{lstlisting}

\subsection{The Reducer}
The Reducer sums up the list of ones.

\begin{lstlisting}[caption=Reducer Implementation]
def reducer(word, counts_list):
    # Aggregates the list [1, 1, 1] into a total sum
    return word, sum(counts_list)
\end{lstlisting}

\section{Who does what}
\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Member} & \textbf{Task} \\ \hline
Nghiêm Xuân Son & Implemented Custom MapReduce Logic \& Report \\ \hline
\end{tabular}
\end{table}

\end{document}